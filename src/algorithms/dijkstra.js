import assign from '101/assign';

import PriorityQueue from '../data-structures/priority-queue';

// costruct
const Graph = function(vertices) {
  // you can either pass a verticies object or add every
  this.vertices = vertices || {};
};
assign(Graph.prototype, {
  // add a vertex to the graph
  addVertex: function(name, edges) {
    this.vertices[name] = edges;
    return this;
  },
  // compute the path
  shortestPath: function(start, finish, options) {
    options = options || {};
    this.nodes = new PriorityQueue();
    this.distances = {};
    this.previous = {};
    this.start = start;
    this.finish = finish;
    // Set the starting values for distances
    this.setBaseline.call(this);
    // loop until we checked every node in the queue
    let smallest;
    let path = [];
    let alt;
    while (!this.nodes.isEmpty()) {
      smallest = this.nodes.dequeue();
      if (smallest === finish) {
        while (this.previous[smallest]) {
          path.push(smallest);
          smallest = this.previous[smallest];
        }
        break;
      }
      if (!smallest || this.distances[smallest] === Infinity) {
        continue;
      }
      for (const neighbor in this.vertices[smallest]) {
        alt = this.distances[smallest] + this.vertices[smallest][neighbor];
        if (alt < this.distances[neighbor]) {
          this.distances[neighbor] = alt;
          this.previous[neighbor] = smallest;
          this.nodes.enqueue(alt, neighbor);
        }
      }
    }
    if (path.length < 1) {
      return null;
    }
    if (options.trim) {
      path.shift();
      // `path` is generated in reverse order
      if (options.reverse) {
        return path;
      }
      return path.reverse();
    }
    path = path.concat([start]);
    if (options.reverse) {
      return path;
    }
    return path.reverse();
  },
  // set the starting point to 0 and all the others to infinite
  setBaseline: function() {
    let vertex;
    for (vertex in this.vertices) {
      if (vertex === this.start) {
        this.distances[vertex] = 0;
        this.nodes.enqueue(0, vertex);
      } else {
        this.distances[vertex] = Infinity;
        this.nodes.enqueue(Infinity, vertex);
      }
      this.previous[vertex] = null;
    }
  },
});

export default Graph;
